// testEvents.dog

LinuxBuild: CPU='amd64' Lang='c++' optimize='speed';


BuildCmd = `g++ -std=gnu++11 testParse.cpp -o test`
Title = "CodeDog parsing test"
FileName = "testGUI.cpp"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "This test file is for testing CodeDog."

featuresNeeded = {GUI_ToolKit = 'GUI' Mouse='GUI' Keyboard='GUI' Audio='GUI'}

LicenseText = `This file is part of the "CodeDog test suite"
The CodeDog test suite is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
The CodeDog test suite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with the CodeDog test suite.  If not, see www.gnu.org/licenses.`

langToGen="CPP"

Include=`<memory>, <fstream>, <cstdint>, <string>, <cstring>, <vector>, <map>, <cstdarg>, <iostream>`

GUI_Spec = {ID='testEvH' appClass="thisApp" runFromMain=1}

initCode="gui_tk.GUI_Init()"
runCode = "gui_tk.GUI_Run()"
deinitCode="gui_tk.GUI_Deinit()"

#include libraryTags.dog

struct GUI_event {
    me uint32: type
    me uint32: value
    me bool: Prime_GUI_event() <- { return(true) }
    me bool: Handle_GUI_event() <- { return(true) }
}

struct GLOBAL {


    me void: GUI_clear_canvas() <- {
      their cairo_t: cr

      cr <- cairo_create(surface)

      cairo_set_source_rgb(cr, 1, 1, 1)
      cairo_paint(cr)

      cairo_destroy(cr)
    }

    me GUI_item: GUI_create_canvas() <- {
        return (gtk_drawing_area_new())
    }


    /* Create a new surface of the appropriate size to store our scribbles */
    me bool: configure_event_cb (their GtkWidget: widget, their GdkEventConfigure: event, me gpointer: data) <- <% {
      if (surface)
        cairo_surface_destroy (surface);

      surface = gdk_window_create_similar_surface (gtk_widget_get_window (widget),
                                                   CAIRO_CONTENT_COLOR,
                                                   gtk_widget_get_allocated_width (widget),
                                                   gtk_widget_get_allocated_height (widget));

      /* Initialize the surface to white */
      GUI_clear_canvas();

      /* We've handled the configure event, no need for further processing. */
      return TRUE;
    } %>

    /* Draw a rectangle on the surface at the given position */
    me void: draw_brush (their GtkWidget: widget,
                me double:    x,
                me double:    y) <- <%{
      cairo_t *cr;

      /* Paint to the surface, where we store our state */
      cr = cairo_create (surface);

      cairo_rectangle (cr, x - 3, y - 3, 6, 6);
      cairo_fill (cr);

      cairo_destroy (cr);

      /* Now invalidate the affected region of the drawing area. */
      gtk_widget_queue_draw_area (widget, x - 3, y - 3, 6, 6);
    } %>

    /* Handle button press events by either drawing a rectangle
     * or clearing the surface, depending on which button was pressed.
     * The ::button-press signal handler receives a GdkEventButton
     * struct which contains this information.
     */
    me bool: button_press_event_cb (their GtkWidget: widget,
                           their GdkEventButton: event,
                           me gpointer:        data) <- <%{
      /* paranoia check, in case we haven't gotten a configure event */
      if (surface == NULL)
        return FALSE;

      if (event->button == GDK_BUTTON_PRIMARY)
        {
          draw_brush (widget, event->x, event->y);
        }
      else if (event->button == GDK_BUTTON_SECONDARY)
        {
          GUI_clear_canvas();
          gtk_widget_queue_draw (widget);
        }

      /* We've handled the event, stop processing */
      return TRUE;
    } %>
    me bool: motion_notify_event_cb (their GtkWidget: widget,
                            their GdkEventMotion: event,
                            me gpointer: data) <- <% {
      /* paranoia check, in case we haven't gotten a configure event */
      if (surface == NULL)
        return FALSE;

      if (event->state & GDK_BUTTON1_MASK)
        draw_brush (widget, event->x, event->y);

      /* We've handled it, stop processing */
      return TRUE;
    } %>
}

struct thisApp{
    me void: createAppMenu(me GUI_menuBar: menubar) <-  {
      me GUI_menu: MenuLvl1
      me GUI_menu: MenuLvl2

      MenuLvl1 <- create_SubMenu(menubar, "File")
            MenuLvl2 <- create_MenuItem(MenuLvl1, "Open")
            MenuLvl2 <- create_SubMenu(MenuLvl1, "Print")
            MenuLvl2 <- create_MenuItem(MenuLvl1, "Save")
            MenuLvl2 <- create_SubMenu(MenuLvl1, "Quit")
      MenuLvl1 <- create_SubMenu(menubar, "View")
      MenuLvl1 <- create_SubMenu(menubar, "Data")
      MenuLvl1 <- create_SubMenu(menubar, "Help")
    }

    me void: HandlePointerBtnDown(me GUI_event: ev) <- {}
    me void: HandlePointerBtnUp  (me GUI_event: ev) <- {}
    me void: HandlePointerMoved  (me GUI_event: ev) <- {}

    me GUI_item: createAppArea() <- {
        me GUI_item: drawing_area
        drawing_area <- gtk_drawing_area_new()

        gtk_widget_set_size_request(drawing_area, 100, 100)

        g_signal_connect (drawing_area, "draw", G_CALLBACK (draw_cb), NULL)
        g_signal_connect (drawing_area,"configure-event", G_CALLBACK (configure_event_cb), NULL)


        g_signal_connect (drawing_area, "motion-notify-event",  G_CALLBACK (motion_notify_event_cb), NULL)
        g_signal_connect (drawing_area, "button-press-event", G_CALLBACK (button_press_event_cb), NULL)


        gtk_widget_set_events(drawing_area, gtk_widget_get_events(drawing_area) + GDK_BUTTON_PRESS_MASK + GDK_POINTER_MOTION_MASK)

        return(drawing_area)

    /*    me GUI_canvas: mainCanvas
        mainCanvas <- GUI_create_canvas()
        mainCanvas.HandlePtrBtnDown <- HandlePointerBtnDown
        mainCanvas.HandlePointerBtnUp <- HandlePointerBtnUp
        mainCanvas.HandlePointerBtnMoved <- HandlePointerBtnMoved
    */
    }
}

do makeGUI(GUI_Spec)
do Write_Main(eventLoop)
