// Test dog file

//LinuxBuild: CPU='amd64' Lang='CPP' optimize='speed';
//AndroidBuild: CPU='arm7' Lang='Java' optimize='speed';
//AppleBuild: CPU='i386' Lang='objectiveC' optimize='clarity';
JavaBuild: Platform='Java' CPU='JavaVM' Lang='Java' optimize='speed';

BuildCmd = `javac test.java`
Title = "CodeDog test suite"
FileName = "test"  //TODO: determine extension for multiple builds
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long, Tiffany Lawrence"
Description = "This test file is for testing CodeDog."

featuresNeeded = {GUI_ToolKit = 'GUI' Mouse='GUI' Keyboard='GUI' Audio='GUI' RandomNumbers=''}

LicenseText = `This file is part of the "CodeDog test suite"
The CodeDog test suite is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
The CodeDog test suite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with the CodeDog test suite.  If not, see www.gnu.org/licenses.`

//langToGen="Java"    // TODO: remove this and grab Lang from build specs

TestList = [abc, def, ghi, jkl]
TestMap = {abc=123 def='hi' LST=[12, 34, 56] MP = {a=b c=d}}

testEventHandling = {ID='testEvH' maxEvents='100000' types=[GUI, LogicAtom] runFromMain=1}

initCode='me bool: isOn'
runCode=''
deinitCode='me char: ste'

Include=`java.lang.String`
#include libraryTags.dog
 
/*
// test class 
struct testClass  {
    me string: address
    me bool: isOn
    me char: ste
    me bool: testFunc (me int32: arg1) <- {
        me int32: X <- 12
        if (X == 1){X <- 2}
        else if(X == 2 ){X <- 3}
        else if(X == 3 ){X <- 4}
        else {print('Hello')}
        return(false)
    }
}
*/



struct timeStamp{me uint32: timeStamp}

struct itemValue{
    me double: value
    me int32:  sourceID
    me int32:  TypeID
    me timeStamp: timestamp
}



struct testTreeMaps{
    me double: minimum
    me double: maximum
    me int32:  precision

    me itemValue[multimap uint32]: dataPoints  
    me testTreeMaps[multimap uint32]: eventTrackers
    me itemValue[map uint32]: valueCache
    //TODO:  private final static Logger logger = Logger.getLogger(testTreeMaps.class.getName());

    me void: addDataPoint(me itemValue: item) <- {dataPoints.insert(item.timestamp, item)}
    me void: delDataPoint(their itemValue: item) <- {}  

    me timeStamp: earliestTimeRecorded() <- {return(dataPoints.front().timestamp)}
    me timeStamp: latestTimeRecorded() <- {return(dataPoints.back().timestamp)}


    me void: populateForTesting(me timeStamp: startTime, me timeStamp: endTime, me int32: lowVal, me int32: highVal, me uint32: numItems) <- {
        me itemValue: val   
        logMesg("POPULATING...") // TODO:  logger.log(Level.INFO, "POPULATING...");
        withEach item in RANGE(0 .. numItems):{
            //TODO: add init code // Random javaRandomVar = new Random();
            val.value <- rand(highVal-lowVal) + lowVal     
            //val.timestamp <- rand(endTime-startTime) + startTime   //TODO: handle long
            //TODO: make c++ and java random number generator for codedog that is like java's next int but with a parameter passed and returns random number between 0 and number passed
            addDataPoint(val)
        }
    }

}

struct test{
    me void: main ()<-{
        me int32: highVal <- 8
        me int32: lowVal <- 2 
        me int64: startTime <- 345678910 
        me int64: endTime <- 345679910
        me int64: numItems <- 345378910
        me int32: myVal <- rand(highVal-lowVal) + lowVal 
        System.out.println("myVal")
        System.out.println(myVal)
        //logMesg("TestClass...")
        me testTreeMaps: myTestTree 
        myTestTree.populateForTesting(startTime,endTime,lowVal,highVal,numItems)
    }
}




do Write_Main(eventLoop)
