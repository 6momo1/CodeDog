//////////////  Add Game-Toolkit features using Android
requirements = [
    [tagOneOf, Platform, [Android]]
]

interface={
    provides=[GameToolkit_implementation]
    libFiles=[]
        headers=[android.app.Activity, android.os.Bundle, android.view.Window, android.view.WindowManager,
        android.content.Context, android.view.View, android.view.SurfaceView,
        android.graphics.Canvas, android.view.MotionEvent, android.view.KeyEvent, android.view.View.OnTouchListener,
        android.view.SurfaceHolder, android.graphics.Color, android.graphics.Paint,
        android.content.res.AssetManager, android.graphics.Bitmap, android.graphics.BitmapFactory,
        android.graphics.Path, android.os.SystemClock, android.graphics.Typeface, android.graphics.Rect
    ]
}

LibDescription ={
    useStatus   = dynamic
    description ='A CodeDog Toolkit for making games'
    features    =[]
    platforms   =[Android]
    bindings    =[Java]
}

initCode = ``
embedHigh = `
class GameModeView extends SurfaceView implements SurfaceHolder.Callback, OnTouchListener{
    public SurfaceHolder surfaceHolder;

    public GameModeView(Context context) {
        super(context);
        getHolder().addCallback(this);
        surfaceHolder = getHolder();
        setFocusable(true);
    }
    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {}
    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        GLOBAL.static_Global.gameLooper.start();
    }
    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {}
    public void update() {}
    @Override
    public void draw(Canvas canvas) {}
    public boolean onTouch(View v, MotionEvent event){
        // Handle touch events
        return true;
    }
}
`
initCode = ``

/////////////////////////////////  STRUCT CONVERTERS
struct GRWindow:                wraps = WindowManager{}
struct GUI_ctxt:                wraps = cairo_t{}
struct INK_Image:               wraps = Paint{}
struct GameSurface:             wraps = SurfaceView{}
struct GameEvent:               wraps = MotionEvent{}
struct UserEvent:               wraps = MotionEvent{}
struct WindowEvent:             wraps = MotionEvent{}
struct KeyboardEvent:           wraps = KeyEvent{}
struct MouseButtonEvent:        wraps = MotionEvent{}
struct MouseMotionEvent:        wraps = MotionEvent{}
struct MouseWheelEvent:         wraps = MotionEvent{}
struct KeyInfo:                 wraps = MotionEvent{}
struct Keycode:                 wraps = MotionEvent{}
struct SoundData:               wraps = Mix_Chunk{}
/////////////////////////////////  GLOBAL
struct GLOBAL: inherits=Activity{
    const int: SCREEN_WIDTH  <- 900
    const int: SCREEN_HEIGHT <- 700

    their GUI_ctxt: createGUI_ctxt()                    <- <%!%G new GUI_ctxt()%>
    void: onCreate(me Bundle: savedInstanceState) <- <%{
        super.onCreate(savedInstanceState);
        GLOBAL.static_Global = this;
        initialize("");
        runDogCode();
        setContentView(gameLooper.crntGameMode.gameModeView);
    }%>
}
/////////////////////////////////  GUI_ctxt
struct GUI_ctxt: inherits=Canvas{
    me Paint: paint
    me Path: GPath
    me double: cur_x
    me double: cur_y
    me Canvas: GCanvas

    me void: setColor(me cdColor: color)                <- <%!%0.paint.setColor( Color.rgb(%1.red, %1.green, %1.blue))%>
    me void: setLineWidth(me double: width)             <- <%!paint.setStrokeWidth(%1)%>
    me void: moveTo(me double: x, me double: y)         <- <%!%0.cur_x=%1; %0.cur_y=%2; %0.GPath.moveTo((float)(%1), (float)(%2))%>
    me void: lineTo(me double: x, me double: y)         <- <%!%0.cur_x=%1; %0.cur_y=%2; %0.GPath.lineTo((float)(%1), (float)(%2))%>
    me void: strokeNow()                                <- <%!%0.paint.setStyle(Paint.Style.STROKE); %0.GCanvas.drawPath(cr.GPath, cr.paint); cr.GPath.rewind()%>
    me void: fillNow()                                  <- <%!%0.paint.setStyle(Paint.Style.FILL);   %0.GCanvas.drawPath(cr.GPath, cr.paint); cr.GPath.rewind()%>
    me void: rectangle(me double: x, me double: y, me double: w, me double: h) <- <%!%0.GCanvas.drawRect((float)%1, (float)%2, (float)%3, (float)%4, cr.paint)%>
    me none: GUI_ctxt () <- {
        Allocate(paint)
        Allocate(GPath)
    }
    me none: GUI_ctxt(me Canvas: canvas) <- {
        Allocate(paint)
        Allocate(GPath)
        GCanvas <- canvas
    }
}
/////////////////////////////////  WINDOW
struct GRWindow{
    void: requestRedraw()                               <- <%!%G%>
}
/////////////////////////////////  LOOPER
struct GameLooper: inherits=Thread{
    our Canvas: canvas
    //me bool: PollForEvent(their GameEvent: event)       <- <%!%>
    void: run() <- <%{
        while(running){
            canvas = null;
            try {
                canvas = crntGameMode.gameModeView.getHolder().lockCanvas();
                GUI_ctxt cr = new GUI_ctxt(canvas);
                synchronized(crntGameMode.gameModeView.surfaceHolder) {
                    this.crntGameMode.gameModeView.update();
                    this.crntGameMode.draw(cr, 0);
                }
            } catch (Exception e) {} finally {
                if (canvas != null) {
                    try {
                        crntGameMode.gameModeView.surfaceHolder.unlockCanvasAndPost(canvas);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }%>
}
struct GameMode{
    our GameModeView: gameModeView

    void: update() <- {}

    void: INIT() <- <%{
        gameModeView = new GameModeView(GLOBAL.static_Global);
    }%>
}
/////////////////////////////////  EVENTS
/////////////////////////////////  IMAGES
/////////////////////////////////  SOUND
