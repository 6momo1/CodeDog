//####### Native CodeDog library
LinuxTestBuild: Platform='Linux' Lang='CPP'  testMode='makeTests';
featuresNeeded = [BigNumbers.CPP]
requirements = [
    [require, BigNumbers_implementation]
]
ProgramOrLibrary = "program"
TestSpec = "BigNumbersTest.dog"
do ManageCmdLine(cmd)
struct GLOBAL{
    me BigInt: min(me BigInt: A, me BigInt: B) <-{
        if(A<=B){return(A)}
        return(B)
    }
    me BigInt: max(me BigInt: A, me BigInt: B) <-{
        if(A>=B){return(A)}
        return(B)
    }
}
struct BigInt{}
struct BigFloat{}
struct BigFrac{}
struct FlexNum{
    me int: decPlaces <- -1
    me BigFrac: val

    void: setNumerator(me string: numerator)
    void: setDenominator(me string: denominator)
    me BigInt: getNumerator()
    me BigInt: getDenominator()

    me int: countDigits(me BigInt:num) <- {
        // TODO: make this use log10(num) + 1
        return(toString(num).size())
    }

    me FlexNum: __plus(me FlexNum: RHS) <- {
        me FlexNum: flexVal;
        flexVal.val         <- val + RHS.val
        me BigInt:flexDenom <- flexVal.getDenominator()
        flexVal.decPlaces   <- countDigits(flexDenom)
        return(flexVal)
    }
    me FlexNum: __minus(me FlexNum: RHS) <- {
        // TODO: make this work for all cases
        me FlexNum: flexVal; flexVal.val <- val - RHS.val
        me BigInt:flexDenom <- flexVal.getDenominator()
        flexVal.decPlaces   <- countDigits(flexDenom)
        return(flexVal)
    }
    me FlexNum: __times(me FlexNum: RHS) <- {
        // TODO: make this work for all cases
        me FlexNum: flexVal; flexVal.val <- val * RHS.val
        me BigInt:flexDenom <- flexVal.getDenominator()
        flexVal.decPlaces   <- countDigits(flexDenom)
        log("TIMES:"+toString(flexVal.val))
        return(flexVal)
    }
    me FlexNum: __divide(me FlexNum: RHS) <- {
        // TODO: make this work for all cases
        me FlexNum: flexVal; flexVal.val <- val / RHS.val
        me BigInt:flexDenom <- flexVal.getDenominator()
        flexVal.decPlaces   <- countDigits(flexDenom)
        return(flexVal)
    }
    me string: stringify() <- {
        if(decPlaces == -1){
            return(toString(val))
        }
        me BigInt: numerator <- getNumerator()
        me BigInt: denominator <- getDenominator()
        //TODO: finish BigFloat{} then replace calculation of S with commented code below
        //me BigFloat: Q <- numerator/denominator
        //me string: S <- Q.stringify()
        me string: numerator <- toString(getNumerator())
        me int: NSize <- numerator.size()
        me int: lDecPlace <- NSize-decPlaces+1
        me string: S <- numerator.subStr(0,lDecPlace)
        if(lDecPlace != NSize){
            S <+- "." + numerator.subStr(lDecPlace, NSize)
        }
        return(S)
    }
    void: fromString(me string: str) <- {
        me int: size <- str.size()
        me int: dotPos <- -1
        withEach idx in RANGE(0..size){
            if(str[idx]=="."){
                dotPos <- idx
                break()
            }
        }
        if(dotPos!=-1){
            decPlaces <- size-dotPos
            me string: numerator   <- str.subStr(0,dotPos)+ str.subStr(dotPos+1,size-decPlaces)
            me string: denominator <- "1"
            withEach n in RANGE(1..decPlaces){
                denominator <+- "0"
            }
            setNumerator(numerator)
            setDenominator(denominator)
        }
        else{
            val <- str
        }
    }
}

