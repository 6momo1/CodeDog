/-############  Add GUI-Toolkit features using Android
requirements = [
    [tagOneOf, Platform, [Android]]
]

interface={
    provides=[GUI_ToolKit_implementation]
    libFiles=[]
    headers=[android.view.View, android.widget.LinearLayout, android.graphics.Canvas, android.graphics.Color, android.graphics.Paint, android.view.Menu, android.graphics.Path, android.widget.ScrollView, android.widget.HorizontalScrollView, android.view.SubMenu, android.widget.TextView, android.graphics.Typeface, android.graphics.Bitmap, android.graphics.BitmapFactory, android.content.res.AssetManager, android.view.MotionEvent ]
}

LibDescription ={
    useStatus  ='dynamic'
    description='GUI for Android '
    features   =[]
    platforms  =[]
    bindings   =[]
    CPUs       =[]
}

/-///////////////////////////////  STRUCT CONVERTERS
struct GUI_rect{me Rect: GUI_rect}
/-struct GUI_offset{their GtkAdjustment:GUI_offset}
struct GUI_item{me Object: GUI_item}
struct GUI_menuBar{me ourSubMenu: GUI_menuBar}
struct GUI_menu{me ourSubMenu: GUI_menu}
struct GUI_menuItem{me MenuItem: GUI_menuItem}
struct GUI_canvas{me CanvasView: GUI_canvas}
struct GUI_container{me LinearLayout:GUI_container}
struct GUI_frame{me LinearLayout:GUI_frame}
struct GUI_ScrollingWindow{me ScrollView: GUI_ScrollingWindow}
struct INK_Image{their Paint: INK_Image}      /- How will the ink look?
struct GUI_callback{me GCallback: GUI_callback}

/-///////////////////////////////  HANDLE EVENTS

struct GUI_MotionEvent{their GdkEventMotion: GUI_MotionEvent}



struct CanvasView: ctxTag="Android" Platform='Java' Lang='Java' LibReq="" implMode="inherit:View" {
    me GUI_ctxt: cr

    me none: CanvasView() <- {super(GLOBAL.static_Global)}
    me void: onDraw(me Canvas: canvas) <- <%{
        super.onDraw(canvas);
        cr = new GUI_ctxt(canvas);
        cr.cur_x=0; cr.cur_y=0;
        cr.GPath.reset();
        GLOBAL.static_Global.drawAppArea_cb(this, cr);
        invalidate();
    }%>

    me bool: onTouchEvent(me MotionEvent: event) <- <%{
        float eventX = event.getX();
        float eventY = event.getY();
        float scrollX = getScrollX();
        float scrollY = getScrollY();
        boolean returnVal = true;

        switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            /-returnVal = GLOBAL.static_Global.thisApp.gui.pointerDown(cr, scrollX + eventX, scrollY + eventY);
            return true;
        case MotionEvent.ACTION_MOVE:
            /-returnVal = GLOBAL.static_Global.thisApp.gui.pointerMoved(cr, scrollX + eventX, scrollY + eventY);
            break;
        case MotionEvent.ACTION_UP:
            /-returnVal = GLOBAL.static_Global.thisApp.gui.pointerUp();
            break;
        case MotionEvent.ACTION_CANCEL:
            /-
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            /-
            break;
        case MotionEvent.ACTION_POINTER_UP:
            /-
            break;
        default:
                return false;
        }

        /- Schedules a repaint.
        if (returnVal == true){invalidate();}
        return returnVal;
    }%>
}


/-///////////////////////////////  HANDLE GUI
struct GUI: implMode="inherit:LinearLayout" {
    me LinearLayout:: frame(GLOBAL.static_Global)
    me LinearLayout:: layoutArea(GLOBAL.static_Global)
    me none: GUI() <- {super(GLOBAL.static_Global)}
    me uint32: GUI_Init() <- <%{return(0);}%>

    me void: GUI_PopulateAndExec() <- <% {
        LinearLayout frame = new LinearLayout(GLOBAL.static_Global);
        frame.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT));
/-        frame.setDefaultCloseOperation(LinearLayout.EXIT_ON_CLOSE);
        GLOBAL.static_Global.setContentView(frame);
        GLOBAL.static_Global.thisApp.createAppArea(frame);
    } %>

    me uint32: GUI_Run() <- <% {
        int status=0;
        GUI_PopulateAndExec();
        return(status);
    } %>
    me void: GUI_Deinit() <- {

    }
    me ScrollView: newScrollingWindow(me Long: A, me Long:B) <- <%{
        ScrollView vScroller = new ScrollView(GLOBAL.static_Global);
        HorizontalScrollView hScroller = new HorizontalScrollView(GLOBAL.static_Global);
        vScroller.addView(hScroller);
        layoutArea = new LinearLayout(GLOBAL.static_Global);
        layoutArea.setOrientation(LinearLayout.VERTICAL);
        hScroller.addView(layoutArea);
        return(vScroller);
    }%>



}

struct GUI: implMode="inherit:LinearLayout"{
    me void: showWidget(me GUI_item: widget) <-  <%!%1.setVisible(true)%>
/-    me GUI_item: newCanvas() <- <%!%Gnew CanvasView()%>
    me void: setWidgetSize(me GUI_item: widget, me uint32: width, me uint32: height) <- <%!%G%1.setLayoutParams(new LayoutParams(%2, %3))%>
    me GUI_item: GUI_menuItemWithLabel(me string: label) <- <%!%Gnew MenuItem(%1)%>
    me GUI_item: GUI_menuWithLabel(me string: label) <- <%!%Gnew Menu(%1)%>
    me void: addToContainer(me GUI_container: container, me GUI_item: widget) <- <%!%G%1.addView(%2)%>
    me void: addToViewport(me GUI_container: container, me GUI_item: widget) <- <%!%Ggui.layoutArea.addView(%2)%>      /- dog file: gui.addToViewport(scroller, drawing_area)
    me void: addMenuBar(me LinearLayout: frame, our GUI_menuBar: menubar) <- {}
    me void: setCallback() <- <%!%G %>
/-    me void: fetchAreaToBeDrawn(me GUI_rect: area) <- <%!;%>
    me GUI_item: GUI_frame(me string: label) <- <%!%Gnew LinearLayout(%1)%>
/-    me GUI_ctxt: newPDF_ctxt()
    me GUI_menuBar: create_TopSubMenu(our GUI_menuBar: dummyMenubar, me string: text) <- {
        me ourSubMenu:: subMenu(text)
        GLOBAL.static_Global.thisApp.menubar.items.add(subMenu)
        return(subMenu)
    }
    me void: create_MenuItem(me GUI_menu: menu, me string: menuLabel) <- {
        our ourSubMenu:: thisMenuItem(menuLabel)
        menu.items.pushLast(thisMenuItem)
    }

}

struct GUI_ctxt: ctxTag="Android" Platform='Android' Lang='Java' LibReq="swing" implMode="inherit:Canvas" {
/-    me void: reset() <- <%!GPath = new Path()%>
    me void: setRGBA(me double: red, me double: green, me double: blue, me double: alpha) <- <%!paint.setColor(Color.argb(%4, %1, %2, %3))%>
    me void: setRGB (me double: red, me double: green, me double: blue) <- <%!paint.setColor(Color.rgb(%1, %2, %3))%>
    me void: setLineWidth(me double: width) <- <%!paint.setStrokeWidth(%1)%>
    me void: finishPDF() <- <%!%GSystem.out.print("PDF Functions not given.")%>
    me void: moveTo(me double: x, me double: y) <- <%!%0.cur_x=%1; %0.cur_y=%2; %0.GPath.moveTo((float)(%1), (float)(%2))%>
    me void: lineTo(me double: x, me double: y) <- <%!%0.cur_x=%1; %0.cur_y=%2; %0.GPath.lineTo((float)(%1), (float)(%2))%>
    me void: moveRel(me double: dx, me double: dy) <- <%!GPath.moveTo((float)(cr.cur_x+%1), (float)(cr.cur_y+%2))%>
    me void: lineRel(me double: dx, me double: dy) <- <%!GPath.lineTo((float)(cr.cur_x+%1), (float)(cr.cur_y+%2))%>
/-    me void: curveTo(me double: x1, me double: y1, me double: x2, me double: y2, me double: x3, me double: y3) <- <%!GPath.curve_to(cr, %1, %2, %3, %4, %5, %6)%>
/-    me void: curveRel(me double: dx1, me double: dy1, me double: dx2, me double: dy2, me double: dx3, me double: dy3) <- <%!rel_curve_to(cr, %1, %2, %3, %4, %5, %6)%>
/-    me void: closePath() <- <%!GPath.closePath()%>
/-    me void: rectangle() <- <%!%0.gr.drawRect(%1, %2, %3, %4)%>
/-    me void: paintNow() <- <%!gr.fill(cr.GPath)%>
    me void: strokeNow() <- <%!GCanvas.drawPath(cr.GPath, cr.paint)%>
    me void: fillNow() <- <%!GCanvas.drawPath(cr.GPath, cr.paint)%>
/-    me void: strokeKeep() <- <%!gr.draw(cr.GPath)%>
/-    me void: fillKeep() <- <%!gr.fill(cr.GPath)%>
/-    me void: renderFrame() <- <%!repaint()%>
}

struct GUI_ctxt: implMode="inherit:Canvas"{
    me Paint: paint
    me Path: GPath
    me double: cur_x
    me double: cur_y
    me Canvas: GCanvas

    me none: GUI_ctxt () <- {
        Allocate(paint)
        Allocate(GPath)
    }

    me none: GUI_ctxt(me Canvas: canvas) <- {
        Allocate(paint)
        Allocate(GPath)
        GCanvas <- canvas
    }
}
/-/////////////////////////////// TIME
struct tm{
    me Calendar: tm
}

struct timeStringer{
    me String: time12Hour() <- <%{
        Calendar timeRec = Calendar.getInstance();
        String AmPm = "am";
        int hours = timeRec.get(Calendar.HOUR);
        /-if (hours>=12) {hours = hours-12; AmPm="pm";}
        if (timeRec.get(Calendar.AM_PM)==Calendar.PM){AmPm="pm";}
        if (hours==0) {hours = 12;}
        String SH = (Integer.toString(hours)+":");
        int min = timeRec.get(Calendar.MINUTE);
        if (min<10){SH = SH+"0";}
        SH = SH + Integer.toString(min);

        SH=SH+":";
        int sec = timeRec.get(Calendar.SECOND);
        if (sec<10){SH = SH+"0";}
        SH = SH + Integer.toString(sec);
        SH=SH+AmPm;
        return(SH);
    } %>
}

/-///////////////////////////////  G L O B A L
struct GLOBAL{
    me APP: thisApp
    me SubMenu: parentMenu
    me AssetManager: assetManager
    
    me void: close_window() <- {
         /- gtk_main_quit()
    }

    /- DRAWING ROUTINES:

    me void: renderText(me GUI_ctxt: cr, me string: text, me string: fontName, me int: fontSize, me int: x, me int: y) <- <%{
        cr.paint.setTextSize(fontSize);
        cr.paint.setTypeface(Typeface.create(fontName, Typeface.NORMAL));
        cr.GCanvas.drawText(text, x, y, cr.paint);
    }%>

    me INK_Image[map string]: InkImgCache
    
    me void: displayImage(me GUI_ctxt: cr, me string: filename, me float: x, me float: y, me double: scale) <- <%{
        boolean filter = false;
        try {
            assetManager = getAssets();
            InputStream is = assetManager.open(filename);
            Bitmap  bitmap = BitmapFactory.decodeStream(is);
            int width  = Math.round((float)scale * bitmap.getWidth());
            int height = Math.round((float)scale * bitmap.getHeight());
            Bitmap newBitmap = Bitmap.createScaledBitmap(bitmap, width,height, filter);
            cr.GCanvas.drawBitmap(newBitmap, x, y, cr.paint);
            Log.v("TAG", "display image: " + filename);
        } catch (IOException e) {Log.e("TAG", e.getMessage());}
   }%>

    me void: markDirtyArea(me GUI_item: widget, me int32: x, me int32: y, me int32: width, me int32: height) <- <%!%G;%>
    me long: ticksPerSec() <- <%!%G1000%>
    me void: copyAssetToWritableFolder(me string: fromPath, me string: toPath)<- <%{
        try {
            InputStream inStream = GLOBAL.static_Global.getAssets().open(fromPath);
            OutputStream outStream = GLOBAL.static_Global.openFileOutput(toPath, Context.MODE_PRIVATE);
            byte[] buf = new byte[1024];
            int len;
            while ((len = inStream.read(buf)) > 0) {
                outStream.write(buf, 0, len);
            }
            outStream.close();
            inStream.close();
        } catch (Exception e) {
            System.out.print(e.getMessage());
        }
    }%>

    /- MENU ROUTINES:
    me boolean: onCreateOptionsMenu(me Menu: androidMenu) <- <%{
        super.onCreateOptionsMenu(androidMenu);
        GLOBAL.static_Global.thisApp.createAppMenu(GLOBAL.static_Global.thisApp.gui.frame);
        GLOBAL.static_Global.addAndroidMenu(androidMenu);
        return true;
    }%>

    me void: addAndroidMenu(me Menu: androidMenu) <- <%{
        int thisSubMenu_key=0;
        for(int thisSubMenuIdx=0; thisSubMenuIdx != GLOBAL.static_Global.thisApp.menubar.items.size(); thisSubMenuIdx += 1){
                ourSubMenu thisSubMenu = GLOBAL.static_Global.thisApp.menubar.items.get(thisSubMenuIdx);
            if (thisSubMenu.items.size() == 0) {
                androidMenu.add(thisSubMenu.name);
            }
            else {
                parentMenu = androidMenu.addSubMenu(thisSubMenu.name);      // working on getting this line to generate right code
                int item_key=0;
                for(int itemIdx=0; itemIdx != thisSubMenu.items.size(); itemIdx += 1){
                                ourSubMenu item = thisSubMenu.items.get(itemIdx);
                    parentMenu.add(item.name);
                    ++item_key;
                }
            } 
            ++thisSubMenu_key;
        }
     }%>
     
    me void: onCreate(me Bundle: savedInstanceState) <- {
        super.onCreate(savedInstanceState)
        GLOBAL.static_Global <- this
        Allocate(thisApp)
        initialize("")
    }

    me void: onStart() <- {
        super.onStart()
        /- The activity is about to become visible. Load state
        """ + runCode + """
    }

    me void: onResume() <- {
        super.onResume()
        /- The activity has become visible (it is now "resumed"). Restart animations, etc.
    }

    me void:  onPause() <- {
        super.onPause()
        /- Another activity is taking focus (this activity is about to be "paused"). Pause animations, etc.
    }

    me void:  onStop() <- {
        super.onStop()
        /- The activity is no longer visible (it is now "stopped")
        /- Make sure state is saved as we may quit soon.
    }

    me void:  onDestroy() <- {
        super.onDestroy()
        deinitialize()
    }
}







struct APP: implMode="inherit:LinearLayout"{
    me none: APP() <- {super(GLOBAL.static_Global)}
    me ourSubMenu:: menubar("menubar")
}

struct ourSubMenu{
    me string: name
    me ourSubMenu[list]: items
    me none: ourSubMenu(me string: menuLabel) <- {name <- menuLabel}
    me none: ourSubMenu() <- {Allocate(items)}
}
