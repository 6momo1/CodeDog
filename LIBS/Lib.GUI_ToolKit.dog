/- CodeDog GUI toolikt
requirements = [
    [require, GUI_ToolKit_implementation]
]

/- Set up a complete application: fonts, colors, a window/frame with a menu, toolbar, app area and optionally a statusbar.
/- Boilerplate details such as resizing windows, etc are taken care of in the best way for each platform.

struct deltaSize{me int: width    me int: height}
struct GUI_rect{me double: x1 me double: y1 me double: x2 me double: y2}
struct GUI_offset{}
struct GUI_ctxt{}


struct GUI_item{}
struct GUI_menuBar{}
struct GUI_menu{}
struct GUI_menuItem{}
struct GUI_canvas{}
struct GUI_container{}
struct GUI_frame{}
struct GUI_ScrollingWindow{}
struct GUI_callback{}
struct GUI_MotionEvent{}
struct GUI_ButtonEvent{}
struct INK_Image{}

struct GUI{
    me void: showWidget(me GUI_item: widget) <- {}
    me GUI_item: newCanvas() <- {}
    me void: setWidgetSize(me GUI_item: widget, me uint32: width, me uint32: height) <- {}
    me GUI_offset: newGUI_offset(me double: value, me double: upper, me double: lower, me double: step_increment, me double: page_increment, me double: page_size) <- {}
    me GUI_item: newScrollingWindow() <- {}
    me GUI_item: newViewport(me GUI_offset: H_Offset, me GUI_offset: V_Offset) <- {}
    me void: addToContainer(me GUI_container: container, me GUI_item: widget) <- {}
    me void: addToViewport(me GUI_container: container, me GUI_item: widget) <- {}
    me void: addMenuBar(me GUI_menuBar: menubar) <- {}
    me void: create_MenuItem()<- {}
    me void: create_TopSubMenu()<- {}
    me void: create_SubMenu()<- {}
    me void: setCallback() <- {}
}

struct GUI_ctxt: ctxTag="GTK3" Platform='PC' LibReq="GTK3" implMode="fromLibAs:cairo_t" {
    their cairo_t:GUI_ctxt
    me void: fetchAreaToBeDrawn(me GUI_rect: area) <- {}
    me void: reset() <- {}
    me void: setRGBA(me double: red, me double: green, me double: blue, me double: alpha) <- {}
    me void: setRGB (me double: red, me double: green, me double: blue) <- {}
    me void: setLineWidth(me double: width) <- {}
    me void: moveTo(me double: x, me double: y) <- {}
    me void: lineTo(me double: x, me double: y) <- {}
    me void: moveRel(me double: dx, me double: dy) <- {}
    me void: lineRel(me double: dx, me double: dy) <- {}
    me void: curveTo(me double: x1, me double: y1, me double: x2, me double: y2, me double: x3, me double: y3) <- {}
    me void: curveRel(me double: dx1, me double: dy1, me double: dx2, me double: dy2, me double: dx3, me double: dy3) <- {}
    me void: rectangle() <- {}
    me void: paintNow() <- {}
    me void: strokeNow() <- {}
    me void: fillNow() <- {}
}


struct color{}
struct colorScheme{}
struct fontSpec{}
struct fontScheme{}

struct App{
    me colorScheme: colors
    me fontScheme: fonts
    me void: createAppMenu(me GUI_frame: frame) <- {}
    me void: createToolBar(me GUI_frame: frame) <- {}
    me void: createAppArea(me GUI_frame: frame) <- {}
    me void: createStatusBar(me GUI_frame: frame) <- {}
}



/------------------------ Widgets and events

struct GUI_PointerEvent{}
struct GUI_ButtonEvent{}
struct GUI_KeyboardEvent{}
struct GUI_WindowEvent{}
struct GUI_DataEvent{}
struct GUI_TimeEvent{}
struct GUI_UserEvent{}
struct GUI_DrawEvent{}


struct widget{
    me uint32: posX
    me uint32: posY
    me uint32: width
    me uint32: height
    me uint32: scale
    me color: defaultColor
    bool: isHidden
    bool: skipEvents

    void: setPos(me int:x, me int:y) <- {posX<-x; posY<-y}

    void: draw(me GUI_ctxt: cr) <- {}
    me bool: handleAllClicks(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: primaryClick(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: primaryDblClick(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: primaryDn(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: primaryUp(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: secondaryClick(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: secondaryDblClick(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: secondaryDn(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: secondaryUp(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: mouseMoved(their GUI_PointerEvent: event) <- {return(false)}
    me bool: mouseDragged(their GUI_PointerEvent: event) <- {return(false)}
    me bool: mouseEnter(their GUI_PointerEvent: event) <- {return(false)}
    me bool: mouseExit(their GUI_PointerEvent: event) <- {return(false)}
    me bool: mouseWheel(their GUI_PointerEvent: event) <- {return(false)}
    me bool: fingerSqueeze(their GUI_PointerEvent: event) <- {return(false)}

    me bool: keyTyped(their GUI_KeyboardEvent: event) <- {return(false)}
    me bool: keyDown(their GUI_KeyboardEvent: event) <- {return(false)}
    me bool: keyUp(their GUI_KeyboardEvent: event) <- {return(false)}

    me bool: windowChange(their GUI_WindowEvent: event) <- {return(false)}
    me bool: dataUpdated(their GUI_DataEvent: event) <- {return(false)}         /- This widget's data has been updated
    me bool: timerTick(their GUI_TimeEvent: event) <- {return(false)}           /- Timer to change data
    me bool: tweenTick(their GUI_TimeEvent: event) <- {return(false)}           /- Timer for state-change animation frame
    me bool: userEvent(their GUI_UserEvent: event) <- {return(false)}
    me bool: focused(their GUI_PointerEvent: event) <- {return(false)}
    me bool: unfocused(their GUI_PointerEvent: event) <- {return(false)}

    bool: isTouchingMe(me int: x, me int: y) <- {
        return ((x >= posX) and (x < posX + width) and (y-20 >= posY) and (y-20 < posY + height))
    }
    void: initialize(me int: PosX, me int: PosY, me int: Width, me int: Height, me int: Scale, me int: Alpha ) <- {
        posX <- PosX
        posY <- PosY
        width <- Width
        height <- Height
        scale <- Scale
        skipEvents <- false
    }
}

struct widget::dashboard{
    our widget::dash[list]: children
    our widget::dash[map string]: dependentItems


    our widget::dash: dependentIsRegistered(me string: key) <- {
        our widget::dash[itr map string]: dashItr <- dependentItems.find(key)
        if (dashItr==dependentItems.end()){return(NULL)}
        return(dashItr.second)  /- TODO: This can't say second. But the type of thing being returned must be compared to the type of the return parameter so the itr can be derefed.
    }

    me bool: addDependent(me string: key, our widget::dash: dashPtr) <- {
        print("Added ", key, "\n")
        our widget::dash[itr map string]: dashItr <- dependentItems.find(key)
        if (dashItr==dependentItems.end()){
            dashPtr.isHidden <- true
            dependentItems[key] <- dashPtr
        }
    }


    me bool: primaryClick(their GUI_ButtonEvent: event) <- {
        if(skipEvents!=0){return(false)}
        if(! isTouchingMe(event.x, event.y)){return(false)}
        print("Clickity Clack!\n")
        withEach Dash in children:{
            Dash.primaryClick(event)
        }
        withEach Dash in dependentItems:{
            if(! Dash.isHidden){
                Dash.primaryClick(event)
            }
        }
        dashBoard.setPos(0, 0)
        markDirtyArea(drawing_area, 0,0,1000,1000)
        return(true)
    }

    me bool: secondaryClick(their GUI_PointerEvent: event) <- {print("RIGHT BUTTON!\n"); return(true)}

    void: update() <- {
    }

    void: setPos(me int: x, me int: y) <- {
        withEach Dash in dependentItems:{
            Dash.isHidden<-true
        }
        withEach Dash in children:{
            Dash.setPos(Dash.posX, Dash.posY)
        }
    }

    void: draw(me GUI_ctxt: cr) <- {
        cr.setRGBA(0, 0, 0, 255)
        cr.setLineWidth(2)
        withEach Dash in children:{
            Dash.draw(cr)
        }
        withEach depDash in dependentItems:{
            if(!depDash.isHidden){
                depDash.draw(cr)
            }
        }
    }
}

struct GLOBAL{
    their widget::dashboard: masterWidget   /-  The widget that will handle most events.
}
