//####### Logger library

requirements = [
    [require, Logger_implementation]
]

struct logger{
    me string: logStr
    me bool: isVisible
    me void: Show()
    me void: Hide()
    me void: Route(me string: routeSpec)
    me void: LogEntry(me string: loggerName, me string: logText) <- {logMgr.writeToLog(loggerName+logText)}
}

struct logManager{
    me string: logFileName  <- "codeDog.log"
    me logger: Mesg
    me logger: Info
    me logger: Critical
    me logger: FatalError
    me logger: Warning
    me logger: Debug
    me mode [ONone, OConsole, OFile, OBoth]: outputMode
    me bool: useLogFile
    me bool: useConsole
    //me void: assert(me string: condition)

    //ShowLogs(InfoLogs | MesgLogs | ...) // ALL_LOGS = the OR of all of them
    //HideLogs(InfoLogs | MesgLogs | ...)
    //RouteLogs(FILE) // Options: stdOut, A file, the platform's system logs, a string

    me void: init(me int: outMode) <- {
        outputMode <- outMode
        if(outputMode == OFile or outputMode == OBoth){useLogFile <- true; openLogFile();}
        else{useLogFile <- false}
        if(outputMode == OConsole or outputMode == OBoth){useConsole <- true;}
        else{useConsole <- false}
    }
}

struct GLOBAL{
    me logManager: logMgr

    void: logSeg(me string: logTxt) <- {logMgr.Mesg.logStr <+- logTxt}
    void: logSegStartCol(me string: logTxt, me int: startPos) <- {
        me int: strLength <- logMgr.Mesg.logStr.size()
        if(strLength < startPos){
            me int: lenDiff <- startPos - strLength
            withEach i in RANGE(0..lenDiff){
                logMgr.Mesg.logStr <+- " "
            }
        }
        logMgr.Mesg.logStr <+- logTxt
    }
    void: logSegClear() <- {logMgr.Mesg.logStr <+- ""}
    void: logFlush() <- {logMgr.writeToLog("MESG: "+logMgr.Mesg.logStr); logMgr.Mesg.logStr <- ""}
    //me void: assert(me string: condition) <- {}
}

struct graphLogger{
    me List<me string>: items
    me string[map string]: rankSlots

    me string: deQuote(me string: S) <-{
        me string: sOut
        withEach idx in RANGE(0..S.size()){
            if(S[idx]=="\""){sOut <+- "\\\""} else{sOut <+- S[idx]}
        }
        return(sOut)
    }
    void: addItem(me string: itemStr)<-{
        itemStr <+- "\n"
        items.append(itemStr)
    }
    void: addNode(me string: nodeID, me string: label, me string: attrs) <-{
        me string: nodeStr <- "    \""+deQuote(nodeID)+"\" "
        me string: labelStr
        if(label != ""){
            labelStr <- "label=\"" + deQuote(label) + "\" "
        }
        me string: attrStr <- labelStr+deQuote(attrs)
        if(attrStr!=""){ attrStr <-  " ["+attrStr+"]"}
        nodeStr <+- attrStr+";\n"
        items.append(nodeStr)
    }
    void: setNodeSlot(me string: nodeID, me string: slotID) <-{
        rankSlots[slotID] <+- "\""+nodeID+"\"; "
    }
    void: addArrow(me string: fromID, me string: toID, me string: label, me string: attrs) <-{
        me string: edgeStr <- "    \""+deQuote(fromID)+"\" -> \"" + deQuote(toID) + "\""
        me string: labelStr
        if(label != ""){
            labelStr <- "label=\"" + deQuote(label) + "\" "
        }
        me string: attrStr <- labelStr+deQuote(attrs)
        if(attrStr!=""){ attrStr <-  " ["+attrStr+"]"}
        edgeStr <+- attrStr+";\n"
        items.append(edgeStr)
    }
    void: clear()<-{items.clear(); rankSlots.clear()}
    void: saveGraph(me string: graphName, me string: filename) <- {
        me FileStream: out
        out.openNew(filename)
        me string: header <- "digraph \""+deQuote(graphName)+"\"{\n"
        out.write(header)
        withEach line in items{
            out.write(line)
        }
        withEach rankItem in rankSlots: {
            me string: sameRank <- "{rank=same; " + rankItem + "}"
            out.write(sameRank)
        }
        me string: footer <- "}\n"
        out.write(footer)
        out.close()
    }
}

struct GLOBAL{
    me graphLogger: grapher
}
