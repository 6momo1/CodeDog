// CodeDog Threads Library

requirements = [
   [tagOneOf, Lang, [Swift]]
]

interface={
    provides=[threads_implementation]
    libFiles=[]
    headers =[]
}

LibDescription  = {
    useStatus   = dynamic
    description = 'Library for multi-thread programming'
    features    = [Threads]
    Lang        = [Swift]
}

embedVeryHigh = `

func __threadedFunction(pointer: UnsafeMutableRawPointer!) -> UnsafeMutableRawPointer? {
    var threadParameter = pointer.load(as: _ThreadParameter.self)
    var pxT = threadParameter.pxT
    var threadIdentifier = threadParameter.threadIdentifier
    pxT.run()
    return nil
}

class _pxThread {
    var notDone:Bool = false
    let _id:String = ""
    var myThread: pthread_t! = nil

    func ID() -> String {return _id}
    func isActive() -> Bool{return true}
    func start(){
        var threadParameter  = _ThreadParameter(threadIdentifier: _ThreadIdentifier(id: _id), pxT: self)
        var pThreadParameter = UnsafeMutablePointer<_ThreadParameter>.allocate(capacity:1)
        pThreadParameter.pointee = threadParameter
        // TODO: Fix &myThread param so it doesn't throw Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value
        let result = pthread_create(&myThread, nil, __threadedFunction, pThreadParameter)
        if result != 0 {print("Error creating thread--"); exit(1);}
    }
    func waitForExit(){pthread_join(myThread!,nil)}
    func run(){}
}
struct _ThreadIdentifier {
  var id: String
}
class _ThreadParameter {
  var threadIdentifier: _ThreadIdentifier
  var pxT: _pxThread

  init(threadIdentifier: _ThreadIdentifier, pxT: _pxThread) {
    self.threadIdentifier = threadIdentifier
    self.pxT = pxT
  }
}

typealias Unique_Lock_Mutex = std::unique_lock<std::mutex>

`
struct Threads: wraps = _pxThread{}
struct Mutex: wraps = mutex{
    void: lock()        <- <%!lock()%>
    void: unlock()      <- <%!unlock()%>
    bool: tryLock()     <- <%!tryLock()%>
}

struct MutexMngr: wraps = Unique_Lock_Mutex{
    void: lock()        <- <%!lock()%>
    void: unlock()      <- <%!unlock()%>
    bool: tryLock()     <- <%!try_lock()%>
}

struct SyncLock: wraps = condition_variable {
    void: wait(me MutexMngr: lock)   <- <%!wait(%1)%>
    void: notifyOne()                <- <%!notify_one()%>
    void: notifyAll()                <- <%!notify_all()%>
}

struct Semaphore: wraps=semaphore {
    void: post()        <- <%!signal()%>
    void: wait()        <- <%!wait()%>
}
