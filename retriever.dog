/- retriever.dog

struct aItem{
    me int: priority
    our infDeepItr: LHS
    our infItr: RHS
    me int: actionCommand
    
    me mode[getAllPlusSize, startPos, endPos, query, size, length, first, last, Nth, tagged, typed]:opTypes
    
    me bool: tryAndFetch()<-{
	
    }

    me void: init(me int: Priority, our infDeepItr: lhs, our infItr: rhs)<-{
	priority <- Priority
	LHS <- lhs
	RHS <- rhs
    }

    me string: printAgendaItem()<-{
	me agent: a
	me string: itemStr <- "" 
	itemStr <- itemStr + a.printInfon(LHS.crntCursor.item)
	itemStr <- itemStr + " |=| "
	itemStr <- itemStr + a.printInfon(RHS.item)
	return(itemStr)
    }
}

struct priorityQ{
    our aItem[list]: theHeap

    me void: push(our aItem: newItem) <- {
	theHeap.pushLast(newItem)
	me int: i <- theHeap.size()-1
	withEach count in WHILE(i !=0 and theHeap[i/2].priority>theHeap[i].priority):{
	    our aItem: tmp <- theHeap[i/2]
	    theHeap[i/2] <-theHeap[i]
	    theHeap[i] <- tmp
	    i <- i/2 /- i is now the parent
	}
    }
    
    our aItem: pop() <- {
	if(theHeap.size()==0){return(NULL)}
	if(theHeap.size()==1){
	    our aItem: tmp <- theHeap[0]
	    theHeap.clear()
	    return(tmp)
	}
	our aItem: root <- theHeap[0]
	theHeap[0] <- theHeap[theHeap.size()-1]
	theHeap.popLast()
	minHeapify(0)
	return(root)
    }
    
    me void: minHeapify(me int: i) <- {
	me int: left <- 2*i+1
	me int: right <- 2*i+2
	me int: smallest <- i
	if (left < theHeap.size() and theHeap[left].priority < theHeap[i].priority){
	    smallest <- left
	}
	if (right < theHeap.size() and theHeap[right].priority < theHeap[smallest].priority){
	    smallest <- right
	}
	if (smallest != i){
	    our aItem: tmp <- theHeap[i]
	    theHeap[i] <-theHeap[smallest]
	    theHeap[smallest] <- tmp
	    minHeapify(smallest)
	}
    }
    
    me bool: isEmpty() <- {
	return(theHeap.size() == 0)
    }
}

struct retriever{
    me priorityQ: agenda
    me int: errorCode
    me string: errorMsg
    their agent: parentAgent
    
    void: addItem(our aItem: item)<-{
/-	prepWorkList(item.LHS.crntCursor)
/-	prepWorkList(item.RHS)
/-	doPreMerge(item)
	/- push onto heap and verify no duplicates
	agenda.theHeap.pushLast(item)
    }
    
    void: processAgenda()<-{
	withEach item in agenda.theHeap:{
	    /-print ("item.priority: ", item.priority, "\n")
	    /-TODO: remove break
	    if (item.priority > 20){
		print("Item priority exceded 20!!!!!\n")
		break()
	    }
	    processItem(item)
	    
	}
    }

    void: processItem(our aItem: actionItem)<-{
/-	me string: S1 <- actionItem.printAgendaItem()
	parentAgent.prepWorkList(actionItem.LHS.crntCursor)
	parentAgent.addWorkItemsToAgenda(actionItem.priority, actionItem.LHS)
	our infItr: remainder <- parentAgent.doMERGE(actionItem.LHS.crntCursor, actionItem.RHS)
	our infItr: newItem_RHS
	our infDeepItr: newItem_LHS <- actionItem.LHS
	newItem_LHS.getNextDeDotted()
	if(newItem_LHS.state == sFirstVisit){
/-	    print ("processItem sFirstVisit: ", actionItem.priority,":", S1,"\n")
	    if(remainder != NULL){
		newItem_RHS <- remainder
	    } else {
		actionItem.RHS.getNextDeDotted()
		newItem_RHS <- actionItem.RHS
	    }
/-	    me string: S2 <- "    newItem_LHS: " + parentAgent.printInfon(newItem_LHS.crntCursor.item) + "\n    newItem_RHS: " + parentAgent.printInfon(newItem_RHS.item)+ "\n"
/-	    print (S2)
	    /- Next list op: process remainder/next | descend
	    if(newItem_LHS.crntCursor.item != NULL and newItem_RHS.item != NULL){
	       /- me string: tmpStr<-parentAgent.printInfon( newItem_LHS.crntCursor.item)
	       /- print("newItem_LHS.crntCursor.item ", "\n")
		if(newItem_LHS.crntCursor.item.value.fType==LST and newItem_RHS.item.value.fType==LST and newItem_LHS.crntCursor.item.value.items.size()>0  and newItem_RHS.item.value.items.size()>0){ /- Descend into lists
		    /-newItem_LHS <- makeInfItr(newItem_LHS.crntCursor.item.value.items[0], newItem_LHS, newItem_LHS.idx)
		    newItem_RHS <- parentAgent.makeInfItr(newItem_RHS.item.value.items[0], newItem_RHS, newItem_RHS.idx)
		    our aItem: nextItem
		    Allocate(nextItem)
		    nextItem.init(actionItem.priority, newItem_LHS, newItem_RHS)
		    addItem(nextItem)
/-		    S1 <- nextItem.printAgendaItem()
/-		    print("    addList: ", S1, "\n")
		}
		else if(newItem_LHS != NULL){
		    our aItem: nextItem
		    Allocate(nextItem)
		    nextItem.init(actionItem.priority + 1, newItem_LHS, newItem_RHS)
		    addItem(nextItem)
/-		    S1 <- nextItem.printAgendaItem()
/-		    print("    addItem: ", S1, "\n")
		}
	    }
	}else if(newItem_LHS.state == sSecondVisit){
/-	    print ("processItem sSecondVisit: ", actionItem.priority,":", S1,"\n")
	    if(newItem_LHS.crntCursor.item.value.fType==LST){ /- ascend out of lists
		newItem_LHS.getNextDeDotted()
		actionItem.RHS.getNextDeDotted()
		newItem_RHS <- actionItem.RHS
		our aItem: nextItem
		Allocate(nextItem)
		nextItem.init(actionItem.priority+1, newItem_LHS, newItem_RHS)
		addItem(nextItem)
	    }
	} else if(newItem_LHS.state == sEOL){
	    /-
	}else {
	    print("Unexpected iterator state in normalizer: ", newItem_LHS.state, ".\n")
	}
    } 

}

