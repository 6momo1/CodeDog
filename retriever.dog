/- retriever.dog

struct aItem{
    me int: priority
    our infDeepItr: LHS
    our infDeepItr: RHS
    me int: actionCommand

    me mode[getAllPlusSize, startPos, endPos, query, size, length, first, last, Nth, tagged, typed]:opTypes

    me bool: tryAndFetch()<-{

    }

    me void: init(me int: Priority, our infDeepItr: lhs, our infDeepItr: rhs)<-{
        priority <- Priority
        LHS <- lhs
        RHS <- rhs
    }

    me string: printAgendaItem()<-{
        me agent: a
        me string: itemStr <- ""
        if (LHS.crntCursor.item!=NULL){itemStr <- itemStr + a.printInfon(LHS.crntCursor.item)}
        else{itemStr <- itemStr +"NULL"}
        itemStr <- itemStr + " |=| "
        if (RHS.crntCursor.item!=NULL){itemStr <- itemStr + a.printInfon(RHS.crntCursor.item)}
        else{itemStr <- itemStr +"NULL"}
        return(itemStr)
    }
}

struct priorityQ{
    our aItem[list]: theHeap

    me void: push(our aItem: newItem) <- {
        theHeap.pushLast(newItem)
        me int: i <- theHeap.size()-1
        withEach count in WHILE(i !=0 and theHeap[i/2].priority>theHeap[i].priority):{
            our aItem: tmp <- theHeap[i/2]
            theHeap[i/2] <-theHeap[i]
            theHeap[i] <- tmp
            i <- i/2 /- i is now the parent
        }
    }

    our aItem: pop() <- {
        if(theHeap.size()==0){return(NULL)}
        if(theHeap.size()==1){
            our aItem: tmp <- theHeap[0]
            theHeap.clear()
            return(tmp)
        }
        our aItem: root <- theHeap[0]
        theHeap[0] <- theHeap[theHeap.size()-1]
        theHeap.popLast()
        minHeapify(0)
        return(root)
    }

    me void: minHeapify(me int: i) <- {
        me int: left <- 2*i+1
        me int: right <- 2*i+2
        me int: smallest <- i
        if (left < theHeap.size() and theHeap[left].priority < theHeap[i].priority){
            smallest <- left
        }
        if (right < theHeap.size() and theHeap[right].priority < theHeap[smallest].priority){
            smallest <- right
        }
        if (smallest != i){
            our aItem: tmp <- theHeap[i]
            theHeap[i] <-theHeap[smallest]
            theHeap[smallest] <- tmp
            minHeapify(smallest)
        }
    }

    me bool: isEmpty() <- {
        return(theHeap.size() == 0)
    }
}

struct retriever{
    me priorityQ: agenda
    me int: errorCode
    me string: errorMsg
    their agent: parentAgent

    void: addItem(our aItem: agendaItem)<-{
/-      prepWorkList(agendaItem.LHS.crntCursor)
/-      prepWorkList(agendaItem.RHS)
/-      doPreMerge(agendaItem)
        /- push onto heap and verify no duplicates
        me string: S1 <- agendaItem.printAgendaItem()
        print ("*********retriever.addItem: ",S1 ,"\n")
        agenda.theHeap.pushLast(agendaItem)
    }

    void: processAgenda()<-{
        print("PROCESS AGENDA\n")
        withEach agendaItem in agenda.theHeap:{
            /-TODO: remove break
            if (agendaItem.priority > 20){
                print("Item priority exceded 20!!!!!\n")
                break()
            }
            processItem(agendaItem)

        }
    }

    void: addItemsToAgenda(me int: priority, our itrChain: LHSChain, our itrChain: RHSChain)<-{
        our itrChain: currentLHS <- LHSChain
        withEach count in WHILE(currentLHS.theItr != NULL):{
            our itrChain: currentRHS <- RHSChain
            withEach count in WHILE(currentRHS.theItr != NULL):{
                our aItem: nextItem
                Allocate(nextItem)
                nextItem.init(priority, currentLHS.theItr, currentRHS.theItr)
                addItem(nextItem)

                currentRHS <- currentRHS.next
            }
            currentLHS <- currentLHS.next
        }
    }

    void: processItem(our aItem: agendaItem)<-{
        me string: S1 <- agendaItem.printAgendaItem()
/-        parentAgent.prepWorkList(agendaItem.LHS.crntCursor)
/-      parentAgent.addWorkItemsToAgenda(agendaItem.priority, agendaItem.LHS)
        our infDeepItr: remainder <- parentAgent.tryMERGE(agendaItem)
        our itrChain: LHSChain <- NULL
        our itrChain: RHSChain <- NULL

        me bool: notEOL <- true
        me bool: remainderSideRHS <- true  /- Later this may be false if the LHS has a remainder
        if(remainder != NULL){
            if(remainderSideRHS){
                Allocate(RHSChain)
                RHSChain.theItr <-remainder
            } else {
                Allocate(LHSChain)
                LHSChain.theItr <-remainder
            }
        }

        if (LHSChain == NULL){
            LHSChain <- agendaItem.LHS.getNextDeDotted()
            if(agendaItem.LHS.state == sSecondVisit){notEOL<-false}
        }
        if (RHSChain == NULL){
            RHSChain <- agendaItem.RHS.getNextDeDotted()
        }

        if (LHSChain != NULL and RHSChain != NULL){
            me int: priority <- agendaItem.priority
            me int: LHS_state <- agendaItem.LHS.state
            if(LHS_state == sFirstVisit){
                if(agendaItem.LHS.crntCursor.item.value.fType!=LST and agendaItem.RHS.crntCursor.item.value.fType!=LST){priority <- priority+1}
                addItemsToAgenda(priority, LHSChain, RHSChain)
            }else if(LHS_state == sSecondVisit){
                addItemsToAgenda(priority + 1, LHSChain, RHSChain)
            } else if(LHS_state == sEOL){
                /-
            }else {
                print("Unexpected iterator state in normalizer: ", LHS_state, ".\n")
            }
        }
    }

}

