/- retriever.dog

struct aItem{
    me int: priority
    our infDeepItr: LHS
    our infDeepItr: RHS
    me int: actionCommand
    
    me mode[getAllPlusSize, startPos, endPos, query, size, length, first, last, Nth, tagged, typed]:opTypes
    
    me bool: tryAndFetch()<-{
	
    }

    me void: init(me int: Priority, our infDeepItr: lhs, our infDeepItr: rhs)<-{
	priority <- Priority
	LHS <- lhs
	RHS <- rhs
    }

    me string: printAgendaItem()<-{
	me agent: a
	me string: itemStr <- ""
	if (LHS.crntCursor.item!=NULL){itemStr <- itemStr + a.printInfon(LHS.crntCursor.item)}
	else{itemStr <- itemStr +"NULL"}
	itemStr <- itemStr + " |=| "
	if (RHS.crntCursor.item!=NULL){itemStr <- itemStr + a.printInfon(RHS.crntCursor.item)}
	else{itemStr <- itemStr +"NULL"}
	return(itemStr)
    }
}

struct priorityQ{
    our aItem[list]: theHeap

    me void: push(our aItem: newItem) <- {
	theHeap.pushLast(newItem)
	me int: i <- theHeap.size()-1
	withEach count in WHILE(i !=0 and theHeap[i/2].priority>theHeap[i].priority):{
	    our aItem: tmp <- theHeap[i/2]
	    theHeap[i/2] <-theHeap[i]
	    theHeap[i] <- tmp
	    i <- i/2 /- i is now the parent
	}
    }
    
    our aItem: pop() <- {
	if(theHeap.size()==0){return(NULL)}
	if(theHeap.size()==1){
	    our aItem: tmp <- theHeap[0]
	    theHeap.clear()
	    return(tmp)
	}
	our aItem: root <- theHeap[0]
	theHeap[0] <- theHeap[theHeap.size()-1]
	theHeap.popLast()
	minHeapify(0)
	return(root)
    }
    
    me void: minHeapify(me int: i) <- {
	me int: left <- 2*i+1
	me int: right <- 2*i+2
	me int: smallest <- i
	if (left < theHeap.size() and theHeap[left].priority < theHeap[i].priority){
	    smallest <- left
	}
	if (right < theHeap.size() and theHeap[right].priority < theHeap[smallest].priority){
	    smallest <- right
	}
	if (smallest != i){
	    our aItem: tmp <- theHeap[i]
	    theHeap[i] <-theHeap[smallest]
	    theHeap[smallest] <- tmp
	    minHeapify(smallest)
	}
    }
    
    me bool: isEmpty() <- {
	return(theHeap.size() == 0)
    }
}

struct retriever{
    me priorityQ: agenda
    me int: errorCode
    me string: errorMsg
    their agent: parentAgent
    
    void: addItem(our aItem: agendaItem)<-{
/-	prepWorkList(agendaItem.LHS.crntCursor)
/-	prepWorkList(agendaItem.RHS)
/-	doPreMerge(agendaItem)
	/- push onto heap and verify no duplicates
	me string: S1 <- agendaItem.printAgendaItem()
	print ("*********retriever.addItem: ",S1 ,"\n")
	agenda.theHeap.pushLast(agendaItem)
    }
    
    void: processAgenda()<-{
	print("PROCESS AGENDA\n")
	withEach agendaItem in agenda.theHeap:{
	    /-TODO: remove break
	    if (agendaItem.priority > 20){
		print("Item priority exceded 20!!!!!\n")
		break()
	    }
	    processItem(agendaItem)
	    
	}
    }

    void: addItemsToAgenda(me int: priority, our itrChain: LHSChain, our itrChain: RHSChain)<-{
	our itrChain: currentLHS <- LHSChain
	withEach count in WHILE(currentLHS.theItr != NULL):{
	    our itrChain: currentRHS <- RHSChain
	    withEach count in WHILE(currentRHS.theItr != NULL):{
		    our aItem: nextItem
		    Allocate(nextItem)
		    if(currentLHS.theItr.crntCursor.item.value.fType==LST and currentRHS.theItr.crntCursor.item.value.fType==LST and currentLHS.theItr.crntCursor.item.value.items.size()>0  and currentRHS.theItr.crntCursor.item.value.items.size()>0){ /- Descend into lists
			nextItem.init(priority, currentLHS.theItr, currentRHS.theItr)
		    }else{
			nextItem.init(priority+1, currentLHS.theItr, currentRHS.theItr)
		    }
		    addItem(nextItem)
		currentRHS <- currentRHS.next
	    }
	    currentLHS <- currentLHS.next
	}
    }
    
    void: processItem(our aItem: agendaItem)<-{
	me string: S1 <- agendaItem.printAgendaItem()
	print("______________________________________________________________\n")
	print ("    PROCESS ITEM priority: ", agendaItem.priority, "|||" ,S1 ,"\n")
	parentAgent.prepWorkList(agendaItem.LHS.crntCursor)
/-	parentAgent.addWorkItemsToAgenda(agendaItem.priority, agendaItem.LHS)
	our infDeepItr: remainder <- parentAgent.tryMERGE(agendaItem)
	our infDeepItr: newItem_LHS <- agendaItem.LHS
	our itrChain: LHSChain
	our itrChain: RHSChain
	/-////////////////////////////////
	print("    LHS.getNextDeDotted\n")
	LHSChain <- newItem_LHS.getNextDeDotted()
	if(newItem_LHS.state == sFirstVisit){
	    print ("    sFirstVisit: \n")
	    if(remainder != NULL){
		Allocate(RHSChain)
		RHSChain.theItr <-remainder
		print("    RHS is remainder.\n")
	    } else {
		print("    RHS.getNextDeDotted\n")
		RHSChain <- agendaItem.RHS.getNextDeDotted()
	    }
	    /- Next list op: process remainder/next | descend
	    if(RHSChain != NULL){
		print("    RHSChain != NULL\n")
		if(newItem_LHS.crntCursor.item != NULL and RHSChain.theItr.crntCursor.item != NULL){
		    addItemsToAgenda(agendaItem.priority, LHSChain, RHSChain)
		}
	    }
	}else if(newItem_LHS.state == sSecondVisit){
	    if(newItem_LHS.crntCursor.item.value.fType==LST){ /- ascend out of lists
		LHSChain <- newItem_LHS.getNextDeDotted()
		RHSChain <- agendaItem.RHS.getNextDeDotted()
		RHSChain.theItr <- agendaItem.RHS
		addItemsToAgenda(agendaItem.priority + 1, LHSChain, RHSChain)
	    }
	} else if(newItem_LHS.state == sEOL){
	    /-
	}else {
	    print("Unexpected iterator state in normalizer: ", newItem_LHS.state, ".\n")
	}
    } 

}

